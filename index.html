<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photo Survey App</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for better aesthetics and responsiveness */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 1rem;
            box-sizing: border-box;
        }
        .container {
            background-color: #ffffff;
            border-radius: 1.5rem; /* More rounded corners */
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            max-width: 600px; /* Adjusted max-width as map is removed */
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
        }
        video, img {
            border-radius: 1rem;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            width: 100%; /* Make video and image responsive */
            max-width: 640px; /* Max width for video/image */
            height: auto;
            background-color: #e2e8f0; /* Placeholder background */
        }
        canvas {
            display: none; /* Canvas is used for capturing, not displaying */
        }
        button {
            transition: all 0.2s ease-in-out;
            transform: translateY(0);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);
        }
        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .info-box {
            background-color: #edf2f7;
            padding: 1rem;
            border-radius: 0.75rem;
            width: 100%;
            text-align: center;
            font-size: 0.95rem;
            color: #4a5568;
        }
        .message-box {
            background-color: #fff3cd; /* Warning yellow */
            color: #856404;
            padding: 1rem;
            border-radius: 0.75rem;
            margin-bottom: 1rem;
            text-align: center;
            border: 1px solid #ffeeba;
            display: none; /* Hidden by default */
        }
        .captured-details {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-top: 1rem;
            padding: 1rem;
            border: 1px solid #e2e8f0;
            border-radius: 0.75rem;
            background-color: #f7fafc;
            width: 100%;
        }
        .captured-details p {
            margin: 0;
            padding: 0.25rem 0;
            color: #2d3748;
        }
        .captured-details p strong {
            color: #1a202c;
        }

        /* Responsive adjustments */
        @media (min-width: 640px) {
            .flex-row-desktop {
                flex-direction: row;
            }
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">
    <div class="container">
        <h1 class="text-3xl font-bold text-gray-800 mb-4">Photo Survey App</h1>

        <!-- Message Box for user feedback -->
        <div id="messageBox" class="message-box"></div>

        <!-- Video element for camera feed -->
        <video id="cameraFeed" class="w-full max-w-md rounded-xl shadow-lg bg-gray-200" autoplay playsinline></video>

        <!-- Canvas for capturing photo -->
        <canvas id="photoCanvas" class="hidden"></canvas>

        <!-- Image element for displaying captured photo -->
        <img id="capturedPhoto" class="w-full max-w-md rounded-xl shadow-lg bg-gray-200 hidden" alt="Captured Photo">

        <!-- Location Information Display -->
        <div class="info-box">
            <p class="text-gray-700 font-semibold">Current Location:</p>
            <p id="latitude" class="text-gray-600">Latitude: N/A</p>
            <p id="longitude" class="text-gray-600">Longitude: N/A</p>
            <p id="dateTime" class="text-gray-600">Date & Time: N/A</p>
        </div>

        <!-- Action Buttons -->
        <div class="flex flex-col sm:flex-row gap-4 w-full justify-center">
            <button id="startCameraButton" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-full shadow-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75">
                Start Camera
            </button>
            <button id="takePhotoButton" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-full shadow-lg focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-75" disabled>
                Take Photo
            </button>
            <button id="retakePhotoButton"
                class="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-3 px-6 rounded-full shadow-lg focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:ring-opacity-75 hidden">
                Retake Photo
            </button>
        </div>

        <!-- Display Captured Photo Details -->
        <div id="capturedPhotoDetails" class="captured-details hidden">
            <h2 class="text-xl font-bold text-gray-800 mb-2">Last Captured Photo Details:</h2>
            <p><strong>Latitude:</strong> <span id="lastLat">N/A</span></p>
            <p><strong>Longitude:</strong> <span id="lastLon">N/A</span></p>
            <p><strong>Date & Time:</strong> <span id="lastDateTime">N/A</span></p>
        </div>
    </div>

    <script>
        // DOM element references
        const cameraFeed = document.getElementById('cameraFeed');
        const photoCanvas = document.getElementById('photoCanvas');
        const capturedPhoto = document.getElementById('capturedPhoto');
        const startCameraButton = document.getElementById('startCameraButton');
        const takePhotoButton = document.getElementById('takePhotoButton');
        const retakePhotoButton = document.getElementById('retakePhotoButton');
        const latitudeSpan = document.getElementById('latitude');
        const longitudeSpan = document.getElementById('longitude');
        const dateTimeSpan = document.getElementById('dateTime');
        const messageBox = document.getElementById('messageBox');
        const capturedPhotoDetails = document.getElementById('capturedPhotoDetails');
        const lastLatSpan = document.getElementById('lastLat');
        const lastLonSpan = document.getElementById('lastLon');
        const lastDateTimeSpan = document.getElementById('lastDateTime');

        let mediaStream = null;
        let currentLatitude = 'N/A';
        let currentLongitude = 'N/A';
        let currentDateTime = 'N/A';

        let lastCoords = {lat: null, lng: null};
        let gettingLocation = false;

        /**
         * Displays a message in the message box.
         * @param {string} message - The message to display.
         * @param {string} type - 'success', 'error', 'warning'.
         */
        function showMessage(message, type) {
            messageBox.textContent = message;
            messageBox.className = 'message-box'; // Reset classes
            messageBox.style.display = 'block'; // Show the box

            switch (type) {
                case 'success':
                    messageBox.classList.add('bg-green-100', 'text-green-800', 'border-green-200');
                    break;
                case 'error':
                    messageBox.classList.add('bg-red-100', 'text-red-800', 'border-red-200');
                    break;
                case 'warning':
                default:
                    messageBox.classList.add('bg-yellow-100', 'text-yellow-800', 'border-yellow-200');
                    break;
            }

            // Hide message after 5 seconds
            setTimeout(() => {
                messageBox.style.display = 'none';
            }, 5000);
        }

        /**
         * Starts the camera feed, prioritizing the back camera and handling errors.
         */
        async function startCamera() {
            // Stop any existing camera stream to ensure a fresh start
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                mediaStream = null; // Clear the stream reference
            }

            // Reset UI state for camera start
            cameraFeed.style.display = 'block'; // Ensure video element is visible
            capturedPhoto.style.display = 'none'; // Ensure captured photo is hidden
            takePhotoButton.disabled = true; // Disable until stream is ready
            startCameraButton.textContent = 'Starting Camera...';
            startCameraButton.disabled = true; // Disable while starting
            showMessage('Starting camera...', 'warning');

            try {
                // Attempt to get the back camera (environment facing)
                mediaStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
                cameraFeed.srcObject = mediaStream;
                // Ensure video starts playing when srcObject is set
                cameraFeed.play();
                takePhotoButton.disabled = false;
                startCameraButton.textContent = 'Camera On (Back)';
                showMessage('Back camera started successfully!', 'success');
            } catch (error) {
                console.error('Error accessing camera:', error);
                // Handle specific errors for better user feedback
                if (error.name === 'OverconstrainedError' || error.name === 'NotFoundError') {
                    showMessage('No back camera found on this device.', 'error');
                } else if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    showMessage('Camera access denied. Please allow camera permissions in your browser settings.', 'error');
                } else {
                    showMessage('An unexpected error occurred while starting the camera.', 'error');
                }
                // Reset buttons and clear stream on failure
                startCameraButton.textContent = 'Start Camera';
                startCameraButton.disabled = false; // Allow retry
                takePhotoButton.disabled = true;
                mediaStream = null;
            }
        }

        /**
         * Resets the view to allow retaking a photo, ensuring the live camera feed resumes.
         */
        function retakePhoto() {
            // Ensure camera feed is visible and photo is hidden
            cameraFeed.style.display = 'block';
            capturedPhoto.style.display = 'none';
            capturedPhotoDetails.classList.add('hidden'); // Hide captured details

            // Re-enable take photo button and hide retake button
            takePhotoButton.disabled = false;
            retakePhotoButton.classList.add('hidden');

            // Crucially, ensure the video element is playing the stream again
            if (mediaStream && mediaStream.active) {
                cameraFeed.srcObject = mediaStream; // Re-assign srcObject (some browsers might need this)
                cameraFeed.play(); // Explicitly play the video stream
                startCameraButton.textContent = 'Camera On'; // Keep text consistent
                startCameraButton.disabled = true; // Keep disabled if camera is on
                showMessage('Ready to take another photo!', 'success');
            } else {
                // If the stream somehow became inactive or was never started, try to start it again
                startCamera();
            }
        }

        /**
         * Gets the current geolocation coordinates.
         * @param {boolean} force - If true, forces a new geolocation lookup even if coordinates haven't changed.
         */
        function getGeolocation(force = false) {
            if (gettingLocation && !force) return; // Prevent multiple requests unless forced

            gettingLocation = true;
            if (navigator.geolocation) {
                showMessage('Fetching location...', 'warning');
                navigator.geolocation.getCurrentPosition(
                    async (position) => {
                        const lat = Number(position.coords.latitude.toFixed(6));
                        const lng = Number(position.coords.longitude.toFixed(6));

                        // Only update if coordinates have significantly changed or if forced
                        if (!force && lat === lastCoords.lat && lng === lastCoords.lng) {
                            gettingLocation = false;
                            showMessage('Location is current.', 'success'); // Indicate no new update needed
                            return;
                        }

                        lastCoords = {lat, lng}; // Update last known coordinates
                        currentLatitude = lat;
                        currentLongitude = lng;
                        currentDateTime = new Date().toLocaleString();

                        latitudeSpan.textContent = `Latitude: ${currentLatitude}`;
                        longitudeSpan.textContent = `Longitude: ${currentLongitude}`;
                        dateTimeSpan.textContent = `Date & Time: ${currentDateTime}`;

                        showMessage('Location updated!', 'success');
                        gettingLocation = false;
                    },
                    (error) => {
                        console.error('Error getting location:', error);
                        let errorMessage = 'Failed to get location.';
                        switch (error.code) {
                            case error.PERMISSION_DENIED:
                                errorMessage += ' Please allow location access.';
                                break;
                            case error.POSITION_UNAVAILABLE:
                                errorMessage += ' Location information is unavailable.';
                                break;
                            case error.TIMEOUT:
                                errorMessage += ' The request to get user location timed out.';
                                break;
                            default:
                                errorMessage += ' An unknown error occurred.';
                                break;
                        }
                        showMessage(errorMessage, 'error');
                        latitudeSpan.textContent = 'Latitude: N/A';
                        longitudeSpan.textContent = 'Longitude: N/A';
                        dateTimeSpan.textContent = 'Date & Time: N/A';
                        gettingLocation = false;
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: 10000, // 10 seconds
                        maximumAge: 0 // No cached position
                    }
                );
            } else {
                showMessage('Geolocation is not supported by your browser.', 'error');
                latitudeSpan.textContent = 'Latitude: Not Supported';
                longitudeSpan.textContent = 'Longitude: Not Supported';
                dateTimeSpan.textContent = 'Date & Time: Not Supported';
                gettingLocation = false;
            }
        }

        /**
         * Captures a photo from the video feed and displays it, along with all collected details.
         */
        function takePhoto() {
            if (!mediaStream) {
                showMessage('Camera not active. Please start the camera first.', 'warning');
                return;
            }

            // Pause the camera feed before drawing to canvas to ensure a clear still frame
            cameraFeed.pause();

            // Set canvas dimensions to match video feed
            photoCanvas.width = cameraFeed.videoWidth;
            photoCanvas.height = cameraFeed.videoHeight;

            const context = photoCanvas.getContext('2d');
            // Draw the current video frame onto the canvas
            context.drawImage(cameraFeed, 0, 0, photoCanvas.width, photoCanvas.height);

            // Get the image data from the canvas
            const imageDataURL = photoCanvas.toDataURL('image/png');

            // Display the captured image
            capturedPhoto.src = imageDataURL;
            capturedPhoto.style.display = 'block'; // Show the captured photo
            cameraFeed.style.display = 'none'; // Hide the camera feed

            // Update last captured photo details
            lastLatSpan.textContent = currentLatitude;
            lastLonSpan.textContent = currentLongitude;
            lastDateTimeSpan.textContent = currentDateTime;
            capturedPhotoDetails.classList.remove('hidden'); // Show the details box

            // Log or use the photo data and coordinates
            console.log('Photo captured!');
            console.log('Latitude:', currentLatitude);
            console.log('Longitude:', currentLongitude);
            console.log('Date & Time:', currentDateTime);
            // console.log('Image Data URL:', imageDataURL.substring(0, 100) + '...'); // Log first 100 chars

            showMessage('Photo captured with all details!', 'success');
        }

        // Event Listeners
        startCameraButton.addEventListener('click', startCamera);
        takePhotoButton.addEventListener('click', () => {
            // Force a location update immediately before taking photo to get the most current data
            getGeolocation(true);
            // Add a small delay to allow geolocation to update before the photo is taken
            // This is a heuristic; actual time needed may vary based on device/network.
            setTimeout(takePhoto, 600);
        });
        retakePhotoButton.addEventListener('click', retakePhoto);

        // Initial setup when the page loads
        // Starts initial geolocation updates and camera
        getGeolocation(true);
        startCamera(); // Call startCamera on page load
        // Periodically update geolocation every 5 seconds.
        setInterval(() => getGeolocation(false), 5000);
    </script>
</body>
</html>
